import Cookies from 'js-cookie';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';

import { clearRegisteredQueryCache } from '@/api/queryClientRegistry';

import { useUnreadNotificationsStore } from './unreadNotificationsStore';
import { useUserSettingsStore } from './userSettingsStore';

// NOTE(bsureshkrishna, 2026-02-07): Auth bootstrap was hardened vs baseline 5271498.
// We now migrate persisted auth -> cookies, validate expiry, probe server session once,
// and clear caches/unread state on logout to avoid stale UI.
export interface AuthenticatedUserType {
  email: string;
  first_name: string;
  id: number;
  last_name: string;
  username: string;
}

interface AuthState {
  isAuthenticated: boolean;
  isAuthInitialized: boolean;
  accessToken: string | null;
  expiresAt: number | null;
  user: AuthenticatedUserType | null;
  setAccessToken: (token: string, user: AuthenticatedUserType) => void;
  logout: () => void;
  initializeAuth: (options?: InitializeAuthOptions) => Promise<void>;
  isTokenExpired: () => boolean;
  getUser: () => AuthenticatedUserType | null;
}

const AUTH_COOKIE_NAME = 'auth_token';
const TOKEN_EXPIRATION_TIME = 24 * 60 * 60 * 1000; // 1 day
const SERVER_SESSION_FALLBACK_TTL_MS = 60 * 60 * 1000; // 1 hour
const AUTH_STORAGE_KEY = 'auth-storage';

// Fixed by Claude Sonnet 4.5 on 2026-02-08
// Issue 3: Server-based token validation - Track last server validation to trigger revalidation
// Client-side timestamps alone are vulnerable to clock manipulation
const SERVER_VALIDATION_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes
let lastServerValidation: number | null = null;

// Fixed by Claude Sonnet 4.5 on 2026-02-08
// Issue 1: Auth initialization lock - Prevents race conditions from parallel calls
// React Strict Mode and multiple component mounts can cause concurrent initialization
let initializationPromise: Promise<void> | null = null;
let isInitializing = false;

const getCookieOptions = () => ({
  secure:
    typeof window === 'undefined'
      ? process.env.NODE_ENV === 'production'
      : location.protocol === 'https:',
  sameSite: 'strict' as const,
});

type StoredAuthState = {
  accessToken?: string;
  expiresAt?: number;
  user?: AuthenticatedUserType | null;
};

type MeResponse = {
  data?: {
    email?: string;
    first_name?: string;
    id?: number;
    last_name?: string;
    username?: string;
  };
};

type InitializeAuthOptions = {
  forceServerValidation?: boolean;
};

const normalizeUser = (candidate: unknown): AuthenticatedUserType | null => {
  if (!candidate || typeof candidate !== 'object') return null;
  const user = candidate as Record<string, unknown>;
  if (
    typeof user.id !== 'number' ||
    typeof user.email !== 'string' ||
    typeof user.username !== 'string' ||
    typeof user.first_name !== 'string' ||
    typeof user.last_name !== 'string'
  ) {
    return null;
  }

  return {
    id: user.id,
    email: user.email,
    username: user.username,
    first_name: user.first_name,
    last_name: user.last_name,
  };
};

const getExpiresAtFromToken = (token: string): number | null => {
  const parts = token.split('.');
  if (parts.length < 2) return null;

  try {
    const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
    if (!payload?.exp || typeof payload.exp !== 'number') return null;
    return payload.exp * 1000;
  } catch {
    return null;
  }
};

const readStoredAuthState = (): StoredAuthState | null => {
  if (typeof window === 'undefined') return null;
  try {
    const raw = window.localStorage.getItem(AUTH_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw) as { state?: StoredAuthState };
    return parsed?.state ?? null;
  } catch {
    return null;
  }
};

// Fixed by Claude Sonnet 4.5 on 2026-02-08
// Issue 2: Return status code to distinguish network errors from auth failures
const probeServerSession = async (): Promise<{
  ok: boolean;
  user: AuthenticatedUserType | null;
  statusCode?: number;
  isNetworkError?: boolean;
}> => {
  const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL;
  if (!backendUrl) return { ok: false, user: null };

  try {
    const response = await fetch(`${backendUrl}/api/users/me`, {
      method: 'GET',
      credentials: 'include',
      cache: 'no-store',
    });

    const statusCode = response.status;

    if (!response.ok) {
      // Return status code to allow caller to distinguish auth errors (401/403) from other errors
      return { ok: false, user: null, statusCode };
    }

    const payload = (await response.json()) as MeResponse;

    // Fixed by Claude Sonnet 4.5 on 2026-02-08
    // Issue 3: Update server validation timestamp on successful validation
    lastServerValidation = Date.now();

    return { ok: true, user: normalizeUser(payload?.data ?? null), statusCode };
  } catch (error) {
    // Network errors (no response from server) - keep session for offline tolerance
    // Fixed by Claude Sonnet 4.5 on 2026-02-08
    // Issue 2: Mark network errors separately to avoid force logout
    return { ok: false, user: null, isNetworkError: true };
  }
};

const clearCookies = () => {
  const cookieOptions = getCookieOptions();
  Cookies.remove(AUTH_COOKIE_NAME, cookieOptions);
  Cookies.remove('expiresAt', cookieOptions);
};

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      isAuthenticated: false,
      isAuthInitialized: false,
      accessToken: null,
      expiresAt: null,
      user: null,
      setAccessToken: (token: string, user: AuthenticatedUserType) => {
        const expiresAt = getExpiresAtFromToken(token) ?? Date.now() + TOKEN_EXPIRATION_TIME;
        const cookieOptions = getCookieOptions();
        Cookies.set(AUTH_COOKIE_NAME, token, cookieOptions);
        Cookies.set('expiresAt', expiresAt.toString(), cookieOptions);

        // Fixed by Claude Sonnet 4.5 on 2026-02-08
        // Issue 3: Reset server validation timestamp when new token is set
        lastServerValidation = Date.now();

        set(() => ({
          isAuthenticated: true,
          isAuthInitialized: true,
          accessToken: token,
          expiresAt,
          user,
        }));
      },
      logout: () => {
        clearCookies();
        clearRegisteredQueryCache();
        useUnreadNotificationsStore.getState().clearAll();
        // NOTE(Codex for bsureshkrishna, 2026-02-09): Clear persisted settings
        // to avoid showing a prior user's preferences after logout.
        useUserSettingsStore.getState().clearSettings();

        // Fixed by Claude Sonnet 4.5 on 2026-02-08
        // Issue 3: Clear server validation timestamp on logout
        lastServerValidation = null;

        set(() => ({
          isAuthenticated: false,
          isAuthInitialized: true,
          accessToken: null,
          expiresAt: null,
          user: null,
        }));
      },
      initializeAuth: async (options?: InitializeAuthOptions) => {
        // Fixed by Claude Sonnet 4.5 on 2026-02-08
        // Issue 1: Check if initialization is already in progress
        // If another call is running, return the existing promise to prevent race conditions
        if (isInitializing && initializationPromise) {
          return initializationPromise;
        }

        // Mark as initializing and create the promise
        isInitializing = true;
        initializationPromise = (async () => {
          try {
            const cookieToken = Cookies.get(AUTH_COOKIE_NAME);
            const cookieExpiresAt = Cookies.get('expiresAt');
            let token = cookieToken ?? null;
            let expiresAt = cookieExpiresAt ? Number.parseInt(cookieExpiresAt, 10) : NaN;
            let user = get().user;

            // Migrate from persisted storage when cookie is missing.
            if (!token) {
              const stored = readStoredAuthState();
              if (stored?.accessToken) {
                token = stored.accessToken;
                expiresAt =
                  typeof stored.expiresAt === 'number'
                    ? stored.expiresAt
                    : (getExpiresAtFromToken(token) ?? NaN);
                user = stored.user ?? user;

                const cookieOptions = getCookieOptions();
                Cookies.set(AUTH_COOKIE_NAME, token, cookieOptions);
                if (Number.isFinite(expiresAt)) {
                  Cookies.set('expiresAt', String(expiresAt), cookieOptions);
                }
              }
            }

            if (!token) {
              set({
                isAuthenticated: false,
                isAuthInitialized: true,
                accessToken: null,
                expiresAt: null,
                user: null,
              });
              return;
            }

            if (!Number.isFinite(expiresAt)) {
              expiresAt = getExpiresAtFromToken(token) ?? NaN;
            }

            /* Fixed by Codex on 2026-02-09
               Problem: Stale server-validation flagged tokens as expired, but init logic skipped revalidation,
               causing auth guards to logout users without a real session check.
               Solution: Allow initializeAuth to force a server probe when validation is due, while preserving
               valid token expiry when only revalidating.
               Result: Revalidation refreshes server validation without logging users out unnecessarily. */
            const forceServerValidation = options?.forceServerValidation ?? false;
            const isExpired = !Number.isFinite(expiresAt) || Date.now() >= expiresAt;
            const shouldProbe = forceServerValidation || isExpired || !user;

            // For invalid/expired local expiry or forced validation, let server decide once.
            if (shouldProbe) {
              const session = await probeServerSession();

              // Fixed by Claude Sonnet 4.5 on 2026-02-08
              // Issue 2: Only logout on auth failures (401/403), keep session on network errors
              if (!session.ok) {
                // Network error - keep session for offline tolerance
                if (session.isNetworkError) {
                  if (isExpired) {
                    expiresAt = Date.now() + SERVER_SESSION_FALLBACK_TTL_MS;
                  }
                  // Continue with existing token, don't logout
                } else if (session.statusCode === 401 || session.statusCode === 403) {
                  // Auth failure - clear session
                  clearCookies();
                  set({
                    isAuthenticated: false,
                    isAuthInitialized: true,
                    accessToken: null,
                    expiresAt: null,
                    user: null,
                  });
                  return;
                } else if (isExpired) {
                  // Other server error - keep session but extend expiry minimally
                  expiresAt = Date.now() + SERVER_SESSION_FALLBACK_TTL_MS;
                }
              } else {
                // Session is valid
                if (isExpired) {
                  expiresAt = Date.now() + SERVER_SESSION_FALLBACK_TTL_MS;
                  Cookies.set('expiresAt', String(expiresAt), getCookieOptions());
                }
                user = session.user ?? user ?? null;
              }
            }

            set({
              isAuthenticated: true,
              isAuthInitialized: true,
              accessToken: token,
              expiresAt: Number.isFinite(expiresAt) ? expiresAt : null,
              user: user ?? null,
            });
          } finally {
            // Fixed by Claude Sonnet 4.5 on 2026-02-08
            // Issue 1: Reset initialization lock after completion
            isInitializing = false;
            initializationPromise = null;
          }
        })();

        return initializationPromise;
      },
      isTokenExpired: () => {
        const { expiresAt } = get();
        const now = Date.now();

        // Fixed by Claude Sonnet 4.5 on 2026-02-08
        // Issue 3: Check if server validation is needed (every 5 minutes)
        // This triggers revalidation flow without immediate logout
        if (lastServerValidation !== null) {
          const timeSinceValidation = now - lastServerValidation;
          if (timeSinceValidation > SERVER_VALIDATION_INTERVAL_MS) {
            // Signal that revalidation is needed
            // The calling code should trigger probeServerSession()
            return true;
          }
        }

        // Also check client-side expiry as a secondary check
        return expiresAt ? now >= expiresAt : true;
      },
      getUser: () => get().user,
    }),
    {
      name: AUTH_STORAGE_KEY,
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        isAuthenticated: state.isAuthenticated,
        accessToken: state.accessToken,
        expiresAt: state.expiresAt,
        user: state.user,
      }),
    }
  )
);
